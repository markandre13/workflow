/*
 *  workflow - A collaborative real-time white- and kanban board
 *  Copyright (C) 2018 Mark-Andr√© Hopf <mhopf@mark13.org>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

native Path;
native Point_ptr;
native Figure_ptr;
native FigureEditor;

valuetype Point {
    public double x, y;
};

valuetype Size {
    public double width, height;
};

valuetype Matrix {
    public double m11, m12, m21, m22, tX, tY;
/*
    // FIXME: declaring operations will make the resulting class 'abstract',
    // previnting us to use it as an attribute because it can not be
    // instantiated. this is were CORBA's factory would be of help, because
    // it could the used to instantiate the real implementation.
    // or we could use the class registered in the ORB, which is similar to
    // the factory.
    // it might also be a good idea to create the valuetypes as interfaces
    // and to provide a utility function for the code we are currently
    // placing within the constructor. this way we could use inheritance
    // without any prototype hacks when implementing the valuetypes.
    // (can interfaces have static functions? also: factory?)

    void identity();
    void append(in Matrix matrix);
    void prepend(in Matrix matrix);
    void invert();
    void translate(in Point point);
    void rotate(in double radiant);
    void scale(in double x, in double y);
    Point transformPoint(in Point point);
//    sequence<double, 2> transformArrayPoint(in sequence<double, 2> point);
// 2 is maximum size, we would like exact size
    sequence<double> transformArrayPoint(in sequence<double> point);
*/
};

valuetype Rectangle {
    public Point origin;
    public Size size;
};

valuetype Figure {
    public unsigned long id;

    Path getPath();
    void translate(in Point delta);
    boolean transform(in Matrix matrix);
    Rectangle bounds();
    double distance(in Point point);
    Point_ptr getHandlePosition(in unsigned short handleId);
    void setHandlePosition(in unsigned short handleId, in Point position);
};

module figure {
    valuetype Shape: Figure {
        public Point origin;
        public Size size;
    };

    valuetype Rectangle: Shape {
    };

    valuetype Circle: Shape {
    };

    valuetype Group: Figure {
	public sequence<Figure> children;
    };

    valuetype Transform: Group {
	public Matrix matrix;
    };

    valuetype Text: Figure {
        public Point origin;
        public string text;
    };
};

valuetype FigureModel {
    public sequence<Figure> data; // FIXME: 'data' is a bad name, how about 'figures'?
};

valuetype Layer: FigureModel {
    public unsigned long id;
    public string name;
    Figure_ptr findFigureAt(in Point point);
};

valuetype User {
    public unsigned long uid;
    public string name;
    public string password;
    public string email;
    public string fullname;
    public string avatar;
};

valuetype Card {
    public unsigned long id;
    public string name;
    public string description;
};

valuetype BoardData {
    public unsigned long bid;
    public string name;
    public string description;
    public sequence<Layer> layers;
};

interface BoardListener {
    oneway void transform(in unsigned long layerID,
                          in sequence<unsigned long> figureIDs,
                          in Matrix matrix,
                          in sequence<unsigned long> newIDs);
};

interface Board {
    BoardData getData();
    oneway void addListener(in BoardListener listener);
    oneway void removeListener(in BoardListener listener);
    // FIXME? how about transforming figures on different layers at the same time?
    oneway void transform(in unsigned long layerID, in sequence<unsigned long> figureIDs, in Matrix matrix);
};

interface Project {
    Board getBoard(in unsigned long boardID);
};

interface Client {
    oneway void logonScreen(in unsigned long lifetime, in string disclaimer, in boolean remember, in string errorMessage);
    oneway void homeScreen(
    	in string cookie,
	in string avatar,
	in string email,
	in string fullname);
};

interface Server {
    oneway void setClient(in Client client);
    oneway void init(in string session);
    oneway void logon(in string user, in string password, in boolean remember);
    oneway void translateFigures(/*in sequence<Figure> figures,*/ in Point delta);
    Project getProject(in unsigned long projectID);
};

interface WorkflowServer {
    Server getServer();
};
